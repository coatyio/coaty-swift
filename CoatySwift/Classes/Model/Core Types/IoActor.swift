//  Copyright (c) 2019 Siemens AG. Licensed under the MIT License.
//
//  IoActor.swift
//  CoatySwift
//
//

import Foundation

/// Defines meta information of an IO actor.
open class IoActor: IoPoint {
    
    // MARK: - Attributes.

    /// The semantic, application-specific data type of values to be consumed
    /// by the IO actor, such as Temperature, Notification, Task, etc.
    /// In order to be associated with an IO source their value types must match.
    ///
    /// The property value must be a non-empty string. You should choose
    /// canonical names for value types to avoid naming collisions. For example,
    /// by following the naming convention for Java packages, such as
    /// `com.mydomain.myapp.Temperature`.
    ///
    /// Note that this value type is different from the underlying data format
    /// used by the IO source to publish IO data values. For example, an IO source
    /// for a temperature sensor could emit values as numbers or as a Value1D
    /// object with specific properties.
    public var valueType: String

    /// Determines whether IO values (generated by external sources)
    /// should be treated as raw strings that are non encoded/decoded as JSON objects.
    /// The value of this property defaults to false.
    public var useRawIoValues: Bool?
    
    // MARK: - Initializers.
    
    init(valueType: String,
         useRawIoValues: Bool? = false,
         updateRate: Double? = nil,
         externalTopic: String? = nil,
         name: String = "IoActorObject",
         objectType: String = "\(COATY_OBJECT_TYPE_NAMESPACE_PREFIX)\(CoreType.IoActor)",
         objectId: CoatyUUID = .init()) {
        self.valueType = valueType
        self.useRawIoValues = useRawIoValues
        super.init(coreType: .IoActor,
                   objectType: objectType,
                   objectId: objectId,
                   name: name,
                   updateRate: updateRate,
                   externalTopic: externalTopic)
    }
    
    // MARK: Codable methods.
    
    enum IoActorKeys: String, CodingKey {
        case valueType
        case useRawIoValues
    }
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: IoActorKeys.self)
        self.valueType = try container.decode(String.self, forKey: .valueType)
        self.useRawIoValues = try container.decodeIfPresent(Bool.self, forKey: .useRawIoValues) ?? false
        try super.init(from: decoder)
    }
    
    open override func encode(to encoder: Encoder) throws {
        try super.encode(to: encoder)
        var container = encoder.container(keyedBy: IoActorKeys.self)
        try container.encode(valueType, forKey: .valueType)
        try container.encodeIfPresent(useRawIoValues, forKey: .useRawIoValues)
    }
}
